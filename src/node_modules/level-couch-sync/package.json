{
  "name": "level-couch-sync",
  "version": "1.2.0",
  "description": "syncronize couchdb data into leveldb",
  "main": "index.js",
  "repository": "",
  "keywords": [
    "leveldb",
    "couchdb",
    "sync",
    "replicate"
  ],
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "dominictarr.com"
  },
  "license": "MIT",
  "dependencies": {
    "request": "~2.14.0",
    "follow": "~0.8.0",
    "backoff": "~2.3.0",
    "another-progress-bar": "~0.1.1"
  },
  "devDependencies": {
    "levelup": "~0.8.0",
    "padded-semver": "~1.0.1",
    "level-sublevel": ">=4.3 <5",
    "memwatch": "~0.2.2"
  },
  "readme": "# level-couch-sync\n\nReplicate couchdb data into leveldb in real time with [follow](https://github.com/iriscouch/follow). Must be used\nwith [sublevel](https://github.com/dominictarr/level-sublevel).\n\n\n## Usage\n\nThe following example illustrates the simplest use case. It will synchronize couchdb data into a leveldb located at `/tmp/level-npm` and store the data as (key, value) = (data.id, JSON.stringify(data.doc)), where data is JSON chunks received from the couch.\n\n``` js\nvar levelCouchSync = require('level-couch-sync')\nvar levelup = require('levelup')\nvar sublevel = require('level-sublevel')\n\nvar db = sublevel(levelup('/tmp/level-npm'))\nlevelCouchSync('http://isaacs.iriscouch.com/registry', db, 'registry-sync')\n```\n\nIf you provide a map/iterator function you can decide for yourself what kind of data your want to persist. An easy \nway to accomplish this, is to create more sublevels and shove data into them. This example shows how you can store\nbasic package metadata in a sublevel named `'package'`:\n\n```js\nvar levelCouchSync = require('level-couch-sync')\nvar levelup = require('levelup')\nvar sublevel = require('level-sublevel')\n\nvar db = sublevel(levelup('/tmp/level-npm-advanced'))\nvar packageDb = db.sublevel('package')\n\nlevelCouchSync('http://isaacs.iriscouch.com/registry', db, 'registry-sync',\n    function (data, emit) {\n      var doc = data.doc\n      emit(data.id, JSON.stringify({\n        name        : doc.name,\n        author      : doc.author,\n        repository  : doc.repository\n      }), packageDb)\n    })\n```\n\nEach `emit()` call adds a (key, value, sublevel) triplet to a batch operation that is executed once the iterator\nreturns, which means you can call `emit()` many times during each time the iterator is invoked.\n\n`levelCouchSync()` returns an EventEmitter, which you can attach listeners to. The following example logs package \nversions and progress to stdout. See the events section for more details.\n\n``` js\n// ..\nvar sync = levelCouchSync(url, db, 'registry-sync')\n\nsync.on('data', function (data) {\n  console.log(data.id, data.doc.versions && Object.keys(data.doc.versions))\n})\nsync.on('progress', function (ratio) {\n  console.log(Math.floor(ratio*10000)/100 + '%')\n})\n```\n\nRun the samples in the ``example/`` folder and try it out! It should work on all systems where \n[levelup](https://github.com/rvagg/node-levelup) can be \ncompiled. If you want to take a closer look at what the data looks like you can use\n[lev](https://github.com/hij1nx/lev), which is an awesome cli tool for viewing any leveldb. All you need is a path \nto it.\n\n## API\n\nThe API is very simple and only contain one function.\n\n### require('level-couch-sync')(sourceUrl, db, metaDb[, map])\n\nThis function returns an `EventEmitter` instance and has three mandatory arguments and one optional.\n\n* `sourceUrl` is a string pointing out the url to the couch we are getting the updates from\n* `db` must be a `level-sublevel` instance and is used to store the data if there is no `map` iterator provided\n* `metaDb` must be a `level-sublevel` instance or a string. If it's a string, a sublevel will be created with that name.\n`metaDb` handles metadata of the ongoing transfer and keeps track of the `update_seq`, which means that if the process \ncrashes, it will automatically continue where it left off\n* `map(data, emit)` is an iterator function called for each JSON data received from the couch. The first argument \n`data` is the JSON received from the couch. `emit(key, value, sublevel)` is a function you call each time you want to \npersist some data. It takes the following three arguments:\n  * `key` is a string and is the key used to store the value\n  * `value` is an object that you are free to build as you please\n  * `sublevel` is a `level-sublevel` instance used to store the `key` and the `value`\n\n\n## Events\n\nlevel-couch-sync emits various events as the leveldb is syncronized with the couch:\n\n* `sync.emit('data', data)` emitted for each data object received from the couch\n* `sync.emit('progress', ratio)` emitted each time data has been written to levelup. The `ratio` is defined as how much data that has been written from the current update sequence. When there is something to be read from the couch then `0 < ratio < 1.0` and when `ratio > 1.0` it means we are syncing live!\n* `sync.emit('fail', err)` emitted when there is an error fetching the\n`sourceUrl` from couchdb before the request will be tried again using fibonacci\nbackoff\n* `sync.emit('max', maxSeq)` emitted when a request has been made to the source url. `maxSeq` is the value of the `update_seq` property in the JSON response\n\n## progress bar\n\nyou can create a progress bar like used in [npmd](github.com/dominictarr/npmd#sync),\njust provide a name for the couchdb, and a function that returns a tagline describing\nthe document that was updated.\n\n``` js\nsync.createProgressBar(name, function (data) {\n  return toTagline(data)\n})\n```\nby default, `name` is the url of the couchdb instance, and the tagline will be `doc._id+'@'+doc._rev`\n\n# License\n\nMIT\n\n",
  "readmeFilename": "README.md",
  "_id": "level-couch-sync@1.2.0",
  "dist": {
    "shasum": "100ecdc8f98b27d37a829eae01143bba5dcc2b0a"
  },
  "_from": "level-couch-sync@",
  "_resolved": "https://registry.npmjs.org/level-couch-sync/-/level-couch-sync-1.2.0.tgz"
}
